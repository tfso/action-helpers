name: 'Setup'
description: ''

inputs:
  environment:
    description: Environment
    required: false

  services:
    description: Services
    required: false

outputs:
  version: 
    description: the full version not including 'v', will be prereleased if build is a branch
    value: ${{ steps.semver.outputs.fullversion }}
  prerelease: 
    description: prerelease suffix for PR builds and will truncate branchname to first word ('feature/my-feature' will be 'feature') unless TRUNCATE_PRERELEASE is set to `false`
    value: ${{ steps.semver.outputs.prerelease }}
  environment: 
    description: environment
    value: ${{ steps.init.outputs.environment }}
  services: 
    description: services
    value: ${{ steps.initServices.outputs.result }}

runs:
  using: 'composite'
  steps:
    - name: initialize default inputs (service)
      id: initServices
      uses: actions/github-script@v6
      with:
        script: |
            return env.services || process.env.SERVICE_NAME;
        env:
          services: format('{0}', inputs.services)

    - name: initialize default inputs (service)
      id: initEnvironment
      uses: actions/github-script@v6
      with:
        script: |
            return env.environment || process.env.DEPLOYMENT_ENVIRONMENT;
        env:
          environment: format('{0}', inputs.environment)
          
    - name: extract tag version
      id: semver 
      uses: booxmedialtd/ws-action-parse-semver@v1.4.7
      with:
        input_string: ${{ github.ref }}
        version_extractor_regex: 'refs\/tags\/v(.*)$'

    - name: extract services
      uses: actions/github-script@v6
      id: script
      with:
        result-encoding: string
        script: |
          if(/^\s*[\[{][\s\S]*[\]}]\s*$/.test(steps.init.outputs.services)) {
            return JSON.stringify([].concat(...[JSON.parse(steps.init.outputs.services)]))
          }
          else {
            return JSON.stringify(
              String(steps.init.outputs.services)
                .split(/[\n]/i)
                .filter(line => line.length > 0)
                .map(line => (
                  /(\w+=([^;]+);)+(\w+=([^;]+))?/g.test(line) == false
                  ? ({ name: line }) 
                  : Object.fromEntries(line
                    .split(/;/g)
                    .map(keyvaluepair => (/(\w+)=(.*)/g.exec(keyvaluepair) ?? []).splice(1))
                  )
              ))
            )
          }